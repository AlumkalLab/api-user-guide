---
layout: page
title: Continuous Integration with Jenkins
tagline:
---

Jenkins is an automation server for running continuous integration tests. The SD2E project uses
[Jenkins](http://jenkins.sd2e.org/) for continuous integration (CI) to ensure
any changes that have been made to apps do not break their
core functionality. It is now standard practice to set up CI for all Agave apps.
This will ensure your deployed app is always up to date with the master branch
of your git repo, and it will alert you if jobs are not working. This guide will
help you integrate continuous integration testing into any app you would like to
deploy, but is not meant to be a replacement for the [Jenkins documentation](https://jenkins.io/doc/).





<br>
#### The Jenkins File
The Jenkins file defines the stages of your Jenkins job and defines the environment
variables for that job. The Jenkins file is written in Groovy, and should be located
at the top-level directory for your app. For the previous fastqc app example, the
Jenkins file would be in the `~/fastqc-app/` directory. Here is an example of the Jenkins
file for the fastqc app:

```
#!groovy

pipeline {
    agent any
    environment {
        AGAVE_JOB_TIMEOUT = 900
        AGAVE_JOB_GET_DIR = "job_output"
        AGAVE_DATA_URI    = "agave://data-sd2e-community/sample/sailfish/test/read1.fastq"
        CONTAINER_REPO    = "fastqc"
        CONTAINER_TAG     = "test"
        AGAVE_CACHE_DIR   = "${HOME}/credentials_cache/${JOB_BASE_NAME}"
        AGAVE_JSON_PARSER = "jq"
        AGAVE_TENANTID    = "sd2e"
        AGAVE_APISERVER   = "https://api.sd2e.org"
        AGAVE_USERNAME    = "sd2etest"
        AGAVE_PASSWORD    = credentials('sd2etest-tacc-password')
        REGISTRY_USERNAME = "sd2etest"
        REGISTRY_PASSWORD = credentials('sd2etest-dockerhub-password')
        REGISTRY_ORG      = credentials('sd2etest-dockerhub-org')
        PATH = "${HOME}/bin:${HOME}/sd2e-cloud-cli/bin:${env.PATH}"
        }
    stages {

        stage('Create Oauth client') {
            steps {
                sh "make-session-client ${JOB_BASE_NAME} ${JOB_BASE_NAME}-${BUILD_ID}"
            }
        }
        stage('Build container') {
            steps {
                sh "apps-build-container -O ${REGISTRY_USERNAME} --image ${CONTAINER_REPO} --tag ${CONTAINER_TAG}"
            }
        }
        stage('Deploy to TACC.cloud') {
            steps {
                sh "apps-deploy -T -O ${REGISTRY_USERNAME} --image ${CONTAINER_REPO} --tag ${CONTAINER_TAG}"
                sh "cat deploy-*"
            }
        }
        stage('Run a test job') {
            steps {
                sh "run-test-job deploy-${AGAVE_USERNAME}-job.json ${AGAVE_JOB_TIMEOUT}"
                // Assumption here is that run_test_job generates a job.jobid file
                // Might be smart to check if it exists if we want to bundle this step with previous in a step
                sh "get-test-job-outputs deploy-${AGAVE_USERNAME}-job.json.jobid ${AGAVE_JOB_GET_DIR}"
            }
        }
        stage('Validate results') {
            steps {
                sh "python -m pytest tests/validate_job --job-directory ${AGAVE_JOB_GET_DIR}"
            }
        }
    }
    post {
        always {
           sh "delete-session-client ${JOB_BASE_NAME} ${JOB_BASE_NAME}-${BUILD_ID}"
        }
        success {
           deleteDir()
        }
    }
}

```

For the most part, you won't need to change any of the environment variables in
the groovy file. All the Jenkins jobs will run as the `sd2etest` user. You will
need to define the input data for your app, see the `AGAVE_DATA_URI` field. If
your test data is located in your private storage system `data-tacc-work-username`,
you'll need to give the `sd2etest` user access to that system with the following
CLI command:
```
systems-roles-addupdate -u sd2etest -r USER data-tacc-work-username
```

The stages of a Jenkins test will also remain largely unchanged. You will always
need to
1. `Create Oauth client`
2. `Build container`
3. `Deploy to TACC.cloud`
4. `Run a test job`, and
5. `Validate results`

To validate your results, you'll need to define pytests that will be run to verify your app is functional.
For the fastqc app, navigate to the tests directory `~/fastqc-app/tests`, and create
a new directory called "validate_job":
```
cd ~/fastqc-app/tests
mkdir validate_job
cd validate_job
```

Create two pytests in that directory, `conftest.py` and `test_files.py`. You can copy/paste
these two examples,
conftest.py:
```
import pytest


def pytest_addoption(parser):
    parser.addoption("--job-directory", action="store", default="job_output",
                     help="Directory containing output to evaluate")


@pytest.fixture
def job_directory(request):
    return request.config.getoption("--job-directory")
```

test_files.py:
```
'''Test for specific files existence in a directory'''
import pytest
import os

'''Parameterize the test with a list of required files'''
@pytest.mark.parametrize("file_list", [
    (['reads1_fastqc.html', 'reads1_fastqc.zip'])
])
def test_files(job_directory,file_list):
    '''checks job_directory for existence of all contents of file_list'''
    # Existence
    listdir = os.listdir(job_directory)
    assert(len(list(set(listdir) & set(file_list))) == len(file_list)), \
        "Missing files"
    # Files are readable and not zero length
    for f in file_list:
        try:
            fstat = os.stat(os.path.join(job_directory, f))
            assert (fstat.st_size > 0), "Zero length file: {}".format(f)
        except Exception:
            raise IOError("Couldn't stat {}".format(f))
```

The conftest.py adds a --job-directory option to pytest, this points to the location of
the output files that are created by running your app. The pytest test_files.py checks if
files exist and are greater than 0 bytes.

If you are creating pytests for a different app, you can simply change the output
file names in line 7 of `test_files.py`, to the file names that are output by your app:

```
'''Parameterize the test with a list of required files'''
@pytest.mark.parametrize("file_list", [
    (['reads1_fastqc.html', 'reads1_fastqc.zip'])
])
```
In this example, Jenkins is testing for the existence of reads1_fastqc.html and
reads1_fastqc.zip, which indicate that the fastqc app ran successfully.

<br>
#### Setting up the Jenkins Server
Now that you've created a groovy file and defined pytests,
you'll need to add your repo to the Jenkins server and define when it should
run tests. We typically have the server run a test every time a changed is pushed
to the master branch, or anytime a merge request to the master branch is made. It
may also be a good idea to schedule weekly or monthly builds to ensure you app
continues working even when no changes have been made to the source repo.

To set up Jenkins tests for your app, follow the instructions in this video tutorial:
<iframe width="560" height="315" src="https://www.youtube.com/embed/XfhgGZ0CAPw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>



---
Return to the [API Documentation Overview](../index.md)
